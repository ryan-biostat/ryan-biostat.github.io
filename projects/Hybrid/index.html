<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <h4 id="about"><strong>About</strong></h4> <p>The MCW Advanced Genomics lab specializes in two sequencing platforms: Oxford Nanopore Long-Read Sequencing (LRS) and Bionano Optical Genome Mapping (OGM). These are two distinct technologies that accomplish two separate goals. OGM uses molecular barcodes to detect medium-to-large structural variants using long strands of DNA that are tagged and stretched out so their patterns can be read. LRS, on the other hand, sequences base-pairs for precise readings of DNA at the most specific of resolution. <strong>What if we could harness the strengths of both technologies?</strong></p> <p>In 2023, Bionano published a <a href="https://bionano.com/wp-content/uploads/2023/08/CG-30073-Bionano-Solve-Theory-of-Operation-Hybrid-Scaffold.pdf" rel="external nofollow noopener" target="_blank">Hybrid Scaffold</a> workflow onto their integrated analysis platform. This tool enabled users to combine sequencing data with OGM data to build scaffolded genomic <a href="https://useast.ensembl.org/info/genome/genebuild/assembly.html" rel="external nofollow noopener" target="_blank">assemblies</a>. Although it was designed for short-read data and later deprecated as the company shifted focus, our lab saw an opportunity to extend its utility.</p> <h2 id="purpose">Purpose</h2> <p>Genomic assemblies are reconstructed versions of an organism’s genome, built by stitching sequencing reads into longer sequences so we can view DNA as continuous contigs, scaffolds, and ideally chromosome-scale structures instead of millions of isolated reads. LRS provides base-level detail and resolves repeats, while OGM contributes large-scale structural information that helps order and orient contigs into larger, more accurate scaffolds.</p> <p>Assembly quality is evaluated using contiguity metrics (<a href="https://en.wikipedia.org/wiki/N50,_L50,_and_related_statistics" rel="external nofollow noopener" target="_blank">N50</a>), completeness (<a href="https://academic.oup.com/bioinformatics/article/31/19/3210/211866" rel="external nofollow noopener" target="_blank">BUSCO scores</a>), and structural accuracy. High-quality assemblies enable more reliable structural variant discovery, resolution of complex regions, and the creation of personalized or population-specific references that improve downstream analysis. By integrating ONT and OGM, this project aims to generate hybrid assemblies that combine precise sequence information with robust large-scale structure.</p> <h2 id="methods">Methods</h2> <p>I adapted the Hybrid Scaffold approach for use with our long-read sequencing data and optimized the workflow for our lab samples.</p> <ol> <li> <h4 id="find-the-deprecated-code"><strong>Find the Deprecated Code</strong></h4> <p>The first step was locating Bionano’s original Hybrid Scaffold workflow within the Access/Compute software package <a href="https://bionano.com/software-downloads/" rel="external nofollow noopener" target="_blank">downloadable</a> from their website. This codebase is large and tightly integrated, containing modules for mapping, assembly, annotation, visualization, and database management. Because Hybrid Scaffold was deprecated years ago, it is no longer documented or exposed through the graphical interface, so identifying it required a systematic search through the underlying directories.</p> </li> <li> <h4 id="learn-and-ingest-the-code"><strong>Learn and Ingest the Code</strong></h4> <p>After finding the Hybrid Scaffold components, I had to understand how they actually worked. The workflow is implemented almost entirely in Perl, with dense subroutines and little documentation, so I systematically read through the scripts to map inputs, outputs, and file handoffs between stages. I specifically looked for where the sequence data, OGM maps, and parameters entered the pipeline, and how intermediate results were written out. Throughout this process, I leaned heavily on large language models to translate unfamiliar Perl idioms into Python-style logic, summarize complex functions, and clarify module interactions, allowing me to quickly build a workable mental model of the original workflow.</p> </li> <li> <h4 id="generate-sufficient-sequencing-data"><strong>Generate Sufficient Sequencing Data</strong></h4> <p>The <a href="https://bionano.com/wp-content/uploads/2023/01/30324-Bionano-Access-Hybrid-Scaffold-Report-Guidelines.pdf" rel="external nofollow noopener" target="_blank">Hybrid Scaffold user manual</a> recommends a minimum contig N50 of 150 kb for input assemblies, so the first requirement on the sequencing side was to produce data capable of meeting or exceeding this threshold. To achieve this, I assembled the ONT long-read data using the <a href="https://github.com/mikolmogorov/Flye" rel="external nofollow noopener" target="_blank">Flye</a> assembler, which is optimized for noisy long reads and designed to maximize contig length. By running Flye on our raw ONT data and iterating on parameters as needed, I was able to boost the N50 of the resulting contigs and generate an assembly that satisfied the 150 kb N50 requirement, making it suitable for downstream hybrid scaffolding with OGM.</p> </li> <li> <h4 id="generate--evaluate-the-assembly"><strong>Generate &amp; Evaluate the Assembly</strong></h4> <p>After preparing the data and integrating the required tools, I executed the Hybrid Scaffold workflow by stepping through each script in sequence to ensure the long-read assembly was formatted and processed correctly. Once the pipeline completed, we generated standard assembly metrics (N50, total assembly size, and structural concordance) to evaluate performance. The resulting hybrid assemblies were highly contiguous providing a reliable and representative reconstruction of each genome.</p> </li> <li> <h4 id="build-a-pipeline"><strong>Build a Pipeline</strong></h4> <p>To streamline the entire process, I developed a Python-based pipeline that orchestrates every step required to prepare ONT data for hybrid assembly. This workflow automates long-read assembly, integrates a phasing step to separate maternal and paternal haplotypes, and formats all outputs into the structures expected by the legacy Hybrid Scaffold modules. Each component is executed with consistent logging and error checking. By consolidating these tasks into a single executable workflow, I created a system that reliably processes new samples and produces hybrid-ready assemblies with minimal manual intervention.</p> </li> </ol> <h2 id="code-sample">Code Sample</h2> <p>A snippet of the Hybrid Assembly Pipeline Code.</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td> <td class="code"><pre><span class="c1"># --- Step 5: Parallel Flye Assemblies ---</span><span class="w">
    </span><span class="n">logger.info</span><span class="p">(</span><span class="s2">"--- Step 5: Submitting Flye assembly jobs in parallel ---"</span><span class="p">)</span><span class="w">
    
    </span><span class="n">assembly_fasta_paths</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="s2">"H1"</span><span class="o">:</span><span class="w"> </span><span class="n">os.path.join</span><span class="p">(</span><span class="n">dirs</span><span class="p">[</span><span class="s2">"flye_split"</span><span class="p">],</span><span class="w"> </span><span class="s2">"H1"</span><span class="p">,</span><span class="w"> </span><span class="s2">"assembly.fasta"</span><span class="p">),</span><span class="w">
        </span><span class="s2">"H2"</span><span class="o">:</span><span class="w"> </span><span class="n">os.path.join</span><span class="p">(</span><span class="n">dirs</span><span class="p">[</span><span class="s2">"flye_split"</span><span class="p">],</span><span class="w"> </span><span class="s2">"H2"</span><span class="p">,</span><span class="w"> </span><span class="s2">"assembly.fasta"</span><span class="p">),</span><span class="w">
        </span><span class="s2">"unsplit"</span><span class="o">:</span><span class="w"> </span><span class="n">os.path.join</span><span class="p">(</span><span class="n">dirs</span><span class="p">[</span><span class="s2">"flye_unsplit"</span><span class="p">],</span><span class="w"> </span><span class="s2">"unsplit"</span><span class="p">,</span><span class="w"> </span><span class="s2">"assembly.fasta"</span><span class="p">)</span><span class="w">
    </span><span class="p">}</span><span class="w">
    
    </span><span class="k">if</span><span class="w"> </span><span class="nf">all</span><span class="p">(</span><span class="n">os.path.exists</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">assembly_fasta_paths.values</span><span class="p">())</span><span class="o">:</span><span class="w">
        </span><span class="n">logger.info</span><span class="p">(</span><span class="s2">"All Flye assembly FASTA files already exist. Skipping Flye assembly step."</span><span class="p">)</span><span class="w">
    </span><span class="k">else</span><span class="o">:</span><span class="w">
        </span><span class="n">flye_commands</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w">
            </span><span class="n">f</span><span class="s2">"conda run -n flye flye --nano-hq {h1_fastq} --out-dir {os.path.join(dirs['flye_split'], 'H1')} --threads {flye_threads_per_job}"</span><span class="p">,</span><span class="w">
            </span><span class="n">f</span><span class="s2">"conda run -n flye flye --nano-hq {h2_fastq} --out-dir {os.path.join(dirs['flye_split'], 'H2')} --threads {flye_threads_per_job}"</span><span class="p">,</span><span class="w">
            </span><span class="n">f</span><span class="s2">"conda run -n flye flye --nano-hq {os.path.abspath(args.input_fastq)} --out-dir {os.path.join(dirs['flye_unsplit'], 'unsplit')} --threads {flye_threads_per_job}"</span><span class="w">
        </span><span class="p">]</span><span class="w">
        </span><span class="n">with</span><span class="w"> </span><span class="n">ProcessPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">executor</span><span class="o">:</span><span class="w">
            </span><span class="n">futures</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">executor.submit</span><span class="p">(</span><span class="n">run_command</span><span class="p">,</span><span class="w"> </span><span class="n">cmd</span><span class="p">,</span><span class="w"> </span><span class="n">logger</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">flye_commands</span><span class="p">]</span><span class="w">
            </span><span class="k">for</span><span class="w"> </span><span class="n">future</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">as_completed</span><span class="p">(</span><span class="n">futures</span><span class="p">)</span><span class="o">:</span><span class="w">
                </span><span class="k">if</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">future.result</span><span class="p">()</span><span class="o">:</span><span class="w">
                    </span><span class="n">logger.error</span><span class="p">(</span><span class="s2">"A Flye assembly job failed. Check logs. Exiting."</span><span class="p">)</span><span class="w">
                    </span><span class="n">sys.exit</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w">
        </span><span class="n">logger.info</span><span class="p">(</span><span class="s2">"--- Flye assemblies completed. ---"</span><span class="p">)</span><span class="w">
    
    </span><span class="c1"># --- Steps 6-9 (Parallel Analysis Workflow) ---</span><span class="w">
    </span><span class="n">logger.info</span><span class="p">(</span><span class="s2">"--- Steps 6-9: Submitting main analysis workflows in parallel ---"</span><span class="p">)</span><span class="w">
    </span><span class="n">final_hybrid_paths</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w">
    
    </span><span class="n">assemblies_to_process</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="s2">"H1"</span><span class="o">:</span><span class="w"> </span><span class="n">assembly_fasta_paths</span><span class="p">[</span><span class="s2">"H1"</span><span class="p">],</span><span class="w">
        </span><span class="s2">"H2"</span><span class="o">:</span><span class="w"> </span><span class="n">assembly_fasta_paths</span><span class="p">[</span><span class="s2">"H2"</span><span class="p">],</span><span class="w">
        </span><span class="s2">"unsplit"</span><span class="o">:</span><span class="w"> </span><span class="n">assembly_fasta_paths</span><span class="p">[</span><span class="s2">"unsplit"</span><span class="p">]</span><span class="w">
    </span><span class="p">}</span><span class="w">
    
    </span><span class="n">with</span><span class="w"> </span><span class="n">ProcessPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">args.max_parallel_jobs</span><span class="p">)</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">executor</span><span class="o">:</span><span class="w">
        </span><span class="n">future_to_assembly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">executor.submit</span><span class="p">(</span><span class="n">process_single_assembly</span><span class="p">,</span><span class="w"> </span><span class="n">base_name</span><span class="p">,</span><span class="w"> </span><span class="n">fasta_path</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="n">dirs</span><span class="p">,</span><span class="w"> </span><span class="n">threads_per_job</span><span class="p">,</span><span class="w"> </span><span class="n">logger</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">base_name</span><span class="w">
            </span><span class="k">for</span><span class="w"> </span><span class="n">base_name</span><span class="p">,</span><span class="w"> </span><span class="n">fasta_path</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">assemblies_to_process.items</span><span class="p">()</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">os.path.exists</span><span class="p">(</span><span class="n">fasta_path</span><span class="p">)</span><span class="w">
        </span><span class="p">}</span><span class="w">
        </span><span class="k">for</span><span class="w"> </span><span class="n">future</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">as_completed</span><span class="p">(</span><span class="n">future_to_assembly</span><span class="p">)</span><span class="o">:</span><span class="w">
            </span><span class="n">assembly_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">future_to_assembly</span><span class="p">[</span><span class="n">future</span><span class="p">]</span><span class="w">
            </span><span class="n">try</span><span class="o">:</span><span class="w">
                </span><span class="n">result_path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">future.result</span><span class="p">()</span><span class="w">
                </span><span class="k">if</span><span class="w"> </span><span class="n">result_path</span><span class="o">:</span><span class="w">
                    </span><span class="n">logger.info</span><span class="p">(</span><span class="n">f</span><span class="s2">"Successfully processed and generated hybrid scaffold for {assembly_name}"</span><span class="p">)</span><span class="w">
                    </span><span class="n">final_hybrid_paths.append</span><span class="p">(</span><span class="n">result_path</span><span class="p">)</span><span class="w">
                </span><span class="k">else</span><span class="o">:</span><span class="w">
                    </span><span class="n">logger.error</span><span class="p">(</span><span class="n">f</span><span class="s2">"Processing failed for {assembly_name}. See worker logs for details."</span><span class="p">)</span><span class="w">
            </span><span class="n">except</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">exc</span><span class="o">:</span><span class="w">
                </span><span class="n">logger.error</span><span class="p">(</span><span class="n">f</span><span class="s1">'{assembly_name} generated an exception: {exc}'</span><span class="p">)</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>Here are some assembly statistics from our hybrid assemblies.</p> <table> <thead> <tr> <th>File</th> <th>Seqs</th> <th>Total bp</th> <th>N50</th> <th>min</th> <th>max</th> <th>N75</th> <th>N90</th> <th>auN</th> </tr> </thead> <tbody> <tr> <td>Raw 1</td> <td>1837.00</td> <td>2692825500.00</td> <td>6452351.00</td> <td>277.00</td> <td>37508636.00</td> <td>3446441.00</td> <td>1505842.00</td> <td>7832347.50</td> </tr> <tr> <td>Raw 2</td> <td>1995.00</td> <td>2741310110.00</td> <td>6941736.00</td> <td>440.00</td> <td>32187494.00</td> <td>3492158.00</td> <td>1338670.00</td> <td>8403763.53</td> </tr> <tr> <td>Hybrid 1</td> <td>169.00</td> <td>3148684920.00</td> <td>62654798.00</td> <td>83587.00</td> <td>138302816.00</td> <td>36582336.00</td> <td>23812109.00</td> <td>68756155.39</td> </tr> <tr> <td>Hybrid 2</td> <td>163.00</td> <td>3112696750.00</td> <td>58418037.00</td> <td>70082.00</td> <td>138312544.00</td> <td>37010218.00</td> <td>24296380.00</td> <td>69158919.08</td> </tr> </tbody> </table> </body></html>